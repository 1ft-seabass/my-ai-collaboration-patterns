# なぜ actionsパターンを採用するのか

このドキュメントでは、actionsパターンがなぜ効果的なのか、その原理と実測データを詳しく解説します。

## 目次

1. [核心的な原理](#核心的な原理)
2. [トークン消費の比較](#トークン消費の比較)
3. [なぜ効率的なのか](#なぜ効率的なのか)
4. [具体的なメリット](#具体的なメリット)
5. [実測データ](#実測データ)
6. [向いているケース・向いていないケース](#向いているケース向いていないケース)

---

## 核心的な原理

> **「コードで縛る」= 仕様明確 = 議論不要 = トークン節約**

actionsパターンの本質は、**曖昧な会話を明確な指示書に置き換える**ことです。

### 会話ベースの根本的な問題

AIアシスタントは、曖昧な指示を受け取ると「確認」のために質問します。これは正しい動作ですが、トークンを大量に消費します。

```
User: "プロジェクトの進捗をコミットして"
      ↓
AI: 「何が曖昧か」を検出
      ↓
AI: "どのファイルをコミットしますか？"  ← 確認質問（トークン消費）
      ↓
User: "全部"
      ↓
AI: "コミットメッセージは？"  ← さらに確認（トークン消費）
      ↓
User: "いい感じに書いて"
      ↓
AI: "分かりました。段階的にコミットしますか？"  ← また確認（トークン消費）
```

**この往復が、トークンを浪費する根本原因です。**

### actionsパターンの解決

明確な指示書を用意すれば、確認は不要になります。

```
User: "@actions/git_commit_and_push.md"
      ↓
AI: 指示書を読み込み（500トークン）
    「段階的にコミット」と明記されている
      ↓
AI: 確認不要で即実行
      ↓
結果のみ報告（1000トークン）
```

**確認の往復がゼロ = トークン大幅削減**

---

## トークン消費の比較

### 会話ベース（従来方式）

典型的な会話ベースのタスク実行：

```
┌─────────────────────────────────────┐
│ User: "進捗をコミットして"           │  100トークン
├─────────────────────────────────────┤
│ AI: "どのファイルをコミットしますか？"│ 2,000トークン
│     （状況確認・説明を含む）          │
├─────────────────────────────────────┤
│ User: "全部"                         │  50トークン
├─────────────────────────────────────┤
│ AI: "コミットメッセージは？"         │ 1,500トークン
│     （提案を含む）                   │
├─────────────────────────────────────┤
│ User: "いい感じに"                   │  80トークン
├─────────────────────────────────────┤
│ AI: "段階的にコミットしますか？"     │ 1,800トークン
│     （説明を含む）                   │
├─────────────────────────────────────┤
│ User: "はい"                         │  50トークン
├─────────────────────────────────────┤
│ AI: 実行して結果報告                 │ 2,500トークン
│     （詳細な説明を含む）             │
└─────────────────────────────────────┘

合計: 約 8,080トークン（4往復）
```

**問題点**:
- 確認のための往復: 3回
- 各応答に説明・提案が含まれる
- トークン消費: 8,000-10,000トークン

### actionsパターン

明確な指示書を使った実行：

```
┌─────────────────────────────────────┐
│ User: "@actions/git_commit_and_push.md" │ 100トークン
├─────────────────────────────────────┤
│ AI: ファイル読み込み                 │ 500トークン
│     （指示書の内容）                 │
│     - 段階的にコミット               │
│     - git status確認                 │
│     - git diff確認                   │
│     - 適切なメッセージ生成           │
│     - git add & commit実行           │
├─────────────────────────────────────┤
│ AI: 即座に実行                       │ 1,500トークン
│     （結果のみ報告）                 │
└─────────────────────────────────────┘

合計: 約 2,100トークン（1往復）
```

**改善点**:
- 確認の往復: 0回
- 説明は最小限
- トークン消費: 2,000-3,000トークン

### 削減率

```
削減率 = (8,080 - 2,100) / 8,080 × 100
      = 約74%
```

**実測では約70%の削減を確認**

---

## なぜ効率的なのか

### 1. 確認の往復がゼロ

**会話ベース**:
- User → AI → User → AI → User → AI（6メッセージ）
- 各往復で2,000-3,000トークン消費

**actionsパターン**:
- User → AI（2メッセージ）
- 1回の実行で2,000-3,000トークン消費

### 2. 説明・報告が最小限

**会話ベース**:
```
AI: "分かりました。まず git status で状況を確認し、
     変更されたファイルを特定します。その後、
     各ファイルの内容を確認して適切なコミット
     メッセージを生成します。段階的にコミット
     することで、履歴が分かりやすくなります..."
```
（説明だけで500トークン）

**actionsパターン**:
```
AI: "コミット完了:
     - feat: ユーザー認証機能を追加
     - fix: エラーハンドリングを改善"
```
（結果のみで100トークン）

### 3. 仕様が明確

**会話ベース**:
- 「いい感じに」→ AIが解釈する必要がある
- 解釈のために追加の確認が必要
- 毎回結果が変わる可能性

**actionsパターン**:
- 指示書に明確に記述
- 解釈の余地なし
- 毎回同じ品質

### 4. コンテキストが最小限

**会話ベース**:
- 会話履歴全体をコンテキストとして保持
- 過去のやり取りも含めて処理
- コンテキストウィンドウを圧迫

**actionsパターン**:
- 指示書のみをコンテキストとして読み込み
- 過去の会話は不要
- コンテキストがクリーン

---

## 具体的なメリット

### 1. トークン削減: 約70%

実測データに基づく削減効果。詳細は[実測データ](#実測データ)を参照。

### 2. 時間短縮: 約50%

確認の往復がないため、実行が速い。

| タスク | 会話ベース | actionsパターン | 短縮率 |
|--------|-----------|-----------------|--------|
| 複雑な操作 | 30-60秒 | 15-25秒 | 約50% |

### 3. 一貫性: 100%

同じ指示書を使えば、毎回同じ品質で実行される。

**会話ベース**:
- 「いい感じに」の解釈が毎回変わる
- コミットメッセージの品質がばらつく
- 手順が省略されることがある

**actionsパターン**:
- 指示書通りに実行
- 毎回同じ手順
- 品質が安定

### 4. 再現性: チーム全体で共有

**会話ベース**:
- 個人の指示方法に依存
- チームで共有困難
- 属人化

**actionsパターン**:
- actions/*.md をGit管理
- チーム全体で同じタスク定義
- 標準化

### 5. 拡張性: 簡単に追加

新しいタスクを `actions/新しいタスク.md` として追加するだけ。

---

## 実測データ

### テスト環境

- **プロジェクト**: joplin-ai-tools
- **AI**: Claude Code
- **期間**: 2025年10月
- **測定方法**: Claude Code のトークンカウンター

### タスク別の削減効果

#### タスク1: Git操作（コミット・プッシュ）

**会話ベース**:
```
User: "進捗をコミットしてプッシュして"
AI: "どのファイルをコミットしますか？"
User: "全部"
AI: "コミットメッセージは？"
User: "いい感じに"
AI: "段階的にコミットしますか？"
User: "はい"
AI: [実行]

トークン消費: 6,000トークン（4往復）
```

**actionsパターン**:
```
User: "@actions/git_commit_and_push.md"
AI: [読み込み→実行]

トークン消費: 1,500トークン（1往復）
```

**削減率**: 75%

#### タスク2: 知見まとめ

**会話ベース**:
```
User: "この進捗で知見をまとめて"
AI: "どの部分をまとめますか？"
User: "重要なところ"
AI: "具体的には？"
User: [説明]
AI: "ノートに書きますか？ADRにしますか？"
User: "ノート"
AI: [実行]

トークン消費: 12,000トークン（5往復）
```

**actionsパターン**:
```
User: "@actions/current_create_knowledge.md"
AI: [読み込み→計画提示→実行]

トークン消費: 4,000トークン（2往復）
```

**削減率**: 67%

#### タスク3: セッション開始

**会話ベース**:
```
User: "最新の申し送りを見て作業開始して"
AI: "どの申し送りですか？"
User: "最新の"
AI: "確認しました。何から始めますか？"
User: "申し送りに書いてある通り"
AI: [実行]

トークン消費: 8,000トークン（4往復）
```

**actionsパターン**:
```
User: "@actions/simple_start_from_latest_letter.md"
AI: [読み込み→申し送り検索→内容確認→実行]

トークン消費: 2,500トークン（1往復）
```

**削減率**: 69%

### 統計サマリー

| タスク | 会話ベース | actions | 削減率 |
|--------|-----------|---------|--------|
| Git操作 | 6,000 | 1,500 | 75% |
| 知見まとめ | 12,000 | 4,000 | 67% |
| セッション開始 | 8,000 | 2,500 | 69% |
| **平均** | **8,667** | **2,667** | **69%** |

### 累計効果

**10回の実行での累計**:
- 会話ベース: 86,670トークン
- actionsパターン: 26,670トークン
- **差**: 60,000トークン節約

**100回の実行での累計**:
- 会話ベース: 866,700トークン
- actionsパターン: 266,700トークン
- **差**: 600,000トークン節約

### コスト換算（参考）

Claude API の料金（2025年10月時点の参考値）:
- Input: $3.00 / 1M tokens
- Output: $15.00 / 1M tokens

**100回の実行での節約**:
- トークン節約: 600,000トークン
- コスト節約: 約 $1.80-$9.00
- **年間（1,000回）**: 約 $18-$90

※ 実際のコストはInput/Outputの比率によって変動

---

## 向いているケース・向いていないケース

### ✅ actionsパターンが向いているケース

#### 1. 繰り返し実行するタスク

**例**:
- 毎日のGitコミット
- 定期的な知見のまとめ
- セッション開始時の準備

**理由**:
- 手順が固定されている
- 毎回同じ確認が必要
- 繰り返すほど累積効果が大きい

#### 2. 手順が決まっているタスク

**例**:
- テスト実行→エラー修正→再実行
- ビルド→デプロイ→確認
- ドキュメント更新→レビュー

**理由**:
- 手順を指示書に明記できる
- 確認の必要がない
- 一貫性が重要

#### 3. 複数のステップがあるタスク

**例**:
- Git status → diff → add → commit → push
- ファイル検索 → 内容確認 → 分析 → まとめ作成
- 申し送り検索 → 読み込み → 理解 → 作業開始

**理由**:
- ステップごとに確認すると往復が増える
- 全体の流れを指示書に書ける
- トークン削減効果が大きい

#### 4. 確認が不要なタスク

**例**:
- 決まった形式でのドキュメント作成
- 定型的なコード生成
- ログの整形

**理由**:
- 自動化可能
- 人間の判断が不要
- 一貫性が保たれる

### ❌ actionsパターンが向いていないケース

#### 1. 一度きりのタスク

**例**:
- プロジェクトの初期セットアップ
- 一度だけの大規模リファクタリング

**理由**:
- 指示書を作る時間が無駄
- 再利用されない
- 会話ベースの方が速い

#### 2. 手順が毎回変わるタスク

**例**:
- 探索的なバグ調査
- 新機能の設計
- アーキテクチャの検討

**理由**:
- 手順を固定できない
- 状況に応じた判断が必要
- 指示書が役に立たない

#### 3. 探索的なタスク

**例**:
- 「何が問題か」を調査
- 「どう実装すべきか」を検討
- 「なぜエラーが起きるか」を分析

**理由**:
- 結果が予測できない
- AIとの対話が重要
- 柔軟性が必要

#### 4. 創造的なタスク

**例**:
- 新しいアイデアのブレインストーミング
- UI/UXデザインの検討
- ドキュメントの執筆（初稿）

**理由**:
- 自由な発想が重要
- 制約が逆効果
- 会話ベースの方が適している

### 判断基準

以下のチェックリストで判断してください：

- [ ] このタスクを3回以上実行する予定がある
- [ ] 手順が明確に定義できる
- [ ] 確認の往復を減らしたい
- [ ] 一貫性が重要

**3つ以上チェックが付けば、actionsパターンが有効です。**

---

## まとめ

### actionsパターンの本質

> **曖昧な会話を明確な指示書に置き換えることで、確認の往復をゼロにする**

### 効果

- **トークン削減**: 約70%（実測値）
- **時間短縮**: 約50%
- **一貫性**: 毎回同じ品質
- **再現性**: チーム全体で共有可能

### 適用の鍵

- 繰り返しタスクから始める
- 手順を明確に定義する
- 期待する結果を明記する
- チームで共有する

### 次のステップ

1. [GUIDE.md](./GUIDE.md) を読んで、actionsパターンをセットアップ
2. [examples/usage-example.md](./examples/usage-example.md) で具体例を確認
3. 自分のプロジェクトで繰り返しタスクを特定
4. `actions/` ディレクトリに指示書を作成
5. 効果を測定して改善

---

**作成日**: 2025-10-25
**バージョン**: 1.0.0
